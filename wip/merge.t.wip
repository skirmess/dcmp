#!perl

use 5.006;
use strict;
use warnings;
use autodie;

use Test::More 0.88;
use Test::TempDir::Tiny;

use Cwd qw(cwd);
use Fcntl ':mode';

use lib qw(.);

main();

sub main {
    require_ok('bin/dcmp') or BAIL_OUT();

#    note('setup configuration for tests with empty @dirs');
    my $basedir = cwd();

    my $tmpdir_l = tempdir();
    my $tmpdir_r = tempdir();

    chdir $tmpdir_l;

    open my $fh, '>', 'a.txt';
    close $fh;

    open $fh, '>', 'b.txt';
    close $fh;

    chdir $tmpdir_r;

    open $fh, '>', 'a.txt';
    close $fh;

    open $fh, '>', 'c.txt';
    close $fh;

    chdir $basedir;

    my $chdir_l = sub { App::dcmp::_chdir($tmpdir_l, @_); };
    my $chdir_r = sub { App::dcmp::_chdir($tmpdir_r, @_); };

    my $collect_file_info = sub { App::dcmp::_collect_file_info(@_); };

    my @dirs;

    my $it_l = App::dcmp::_iterator_dir_fs($chdir_l, $collect_file_info, \@dirs);
    my $it_r = App::dcmp::_iterator_dir_fs($chdir_r, $collect_file_info, \@dirs);

    my $it = App::dcmp::_merge_iterators($it_l, $it_r);
    is(ref $it, ref sub {}, '_merge_iterators() returns a sub');

    #
    note('first merged file info');
    my $merged_file_info = $it->();
    is(ref $merged_file_info, ref [], 'merged file info is an array ref');
    is(scalar @{ $merged_file_info }, 2, '... consisting of two values');
    is(ref ${$merged_file_info}[0], ref [], '... first value is an array ref');
    is(ref ${$merged_file_info}[1], ref [], '... second value is an array ref');

    my $file_info = ${ $merged_file_info}[0];
    is(scalar @{ $file_info }, 3, '... first consists of three values');
    is(${ $file_info }[0], 'a.txt', '... the file name');
    like(${$file_info}[1], qr{ ^ [0-9]+ $ }xsm, '... the mode');
    ok(S_ISREG(${$file_info}[1]), '... which is from a file');
    is(${$file_info}[2], 0, '... the file size');

    $file_info = ${ $merged_file_info}[1];
    is(scalar @{ $file_info }, 3, '... second consists of three values');
    is(${ $file_info }[0], 'a.txt', '... the file name');
    like(${$file_info}[1], qr{ ^ [0-9]+ $ }xsm, '... the mode');
    ok(S_ISREG(${$file_info}[1]), '... which is from a file');
    is(${$file_info}[2], 0, '... the file size');

    #
    note('second merged file info');
    $merged_file_info = $it->();
    is(ref $merged_file_info, ref [], 'merged file info is an array ref');
    is(scalar @{ $merged_file_info }, 2, '... consisting of two values');
    is(ref ${$merged_file_info}[0], ref [], '... first value is an array ref');
    is(${$merged_file_info}[1], undef, '... second value is undef');

    $file_info = ${ $merged_file_info}[0];
    is(ref $file_info, ref [], 'file info is an array ref');
    is(scalar @{ $file_info }, 3, '... consisting of three values');
    is(${ $file_info }[0], 'b.txt', '... the file name');
    like(${$file_info}[1], qr{ ^ [0-9]+ $ }xsm, '... the mode');
    ok(S_ISREG(${$file_info}[1]), '... which is from a file');
    is(${$file_info}[2], 0, '... the file size');

    #
    note('third mergedfile info');
    $merged_file_info = $it->();

    is(ref $merged_file_info, ref [], 'merged file info is an array ref');
    is(scalar @{ $merged_file_info }, 2, '... consisting of two values');
    is(${$merged_file_info}[0], undef, '... first value is undef');
    is(ref ${$merged_file_info}[1], ref [], '... second value is an array ref');

    $file_info = ${ $merged_file_info}[1];
    is(ref $file_info, ref [], 'file info is an array ref');
    is(scalar @{ $file_info }, 3, '... consisting of three values');
    is(${ $file_info }[0], 'c.txt', '... the file name');
    like(${$file_info}[1], qr{ ^ [0-9]+ $ }xsm, '... the mode');
    ok(S_ISREG(${$file_info}[1]), '... which is from a file');
    is(${$file_info}[2], 0, '... the file size');

    #
    note('fourth file info');
    is($it->(), undef, 'merged file info is undef - iterator is exhausted.');

    #
    done_testing();

    exit 0;
}

# vim: ts=4 sts=4 sw=4 et: syntax=perl
