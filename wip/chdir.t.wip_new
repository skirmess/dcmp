#!perl

use 5.006;
use strict;
use warnings;
use autodie;

use Test::More 0.88;
use Test::TempDir::Tiny;
use Test::Fatal;

use Cwd qw(abs_path cwd);
use File::Spec;

use lib qw(.);

main();

sub _cwd {
    my $cwd = cwd();
    utf8::decode($cwd);
    return File::Spec->canonpath( $cwd );
}

sub main {
    require_ok('bin/dcmp') or BAIL_OUT();

    my $basedir = cwd();

    #
    note('basedir, no dirs');
    my $tmpdir = tempdir();
    $tmpdir = abs_path $tmpdir;

    is( App::DCMP::_chdir( $tmpdir, undef ), undef, '_chdir($tmpdir, undef) returns undef' );
    is( cwd(), $tmpdir, '... and the cwd is now $tmpdir' );

    #
  SKIP: {
        skip 'chmod 0 does not prevent us from entering a directory on Windows' if $^O eq 'MSWin32';

        note('basedir without permissions, no dirs');
        chdir $basedir;
        chmod 0, $tmpdir;

        like( exception { App::DCMP::_chdir( $tmpdir, undef ) }, "/ ^ \QCannot chdir to $tmpdir: \E /xsm", '_chdir($tmpdir, undef) throws am error' );
        is( cwd(), $basedir, '... and the cwd is not changed' );
    }

    #
    note('basedir, 26 dirs');
    $tmpdir = tempdir();
    $tmpdir = abs_path $tmpdir;

    chdir $tmpdir;
    for my $d ( 'a' .. 'z' ) {
        mkdir $d;
        chdir $d;
    }

    chdir $basedir;

    my @dirs = ( 'a' .. 'z' );

    is( App::DCMP::_chdir( $tmpdir, \@dirs ), undef, '_chdir($tmpdir, \@dirs) returns undef' );
    is( _cwd(), File::Spec->catdir( $tmpdir, 'a' .. 'z' ), '... and the cwd is correct' );

    #
  SKIP: {
        skip 'chmod 0 does not prevent us from entering a directory on Windows' if $^O eq 'MSWin32';

        note('basedir, 26 dirs, one without permissions');

        chmod 0, File::Spec->catdir( $tmpdir, 'a' .. 'f' );

        chdir $basedir;

        my $last_good_dir = File::Spec->catdir( $tmpdir, 'a' .. 'e' );
        like( exception { App::DCMP::_chdir( $tmpdir, \@dirs ) }, "/ ^ \QCannot chdir to f in $last_good_dir: \E /xsm", '_chdir($tmpdir, \@dirs) throws an error' );
        is( cwd(), $last_good_dir, '... and the cwd is changed up to where the error happend' );
    }

    #
    note('test with Unicode directory names');

    $tmpdir = tempdir();
    $tmpdir = abs_path $tmpdir;

    my @dirs = (
        "\N{U+20A0}",
"\N{U+20A1}",
"\N{U+20A2}",
"\N{U+20A3}",
"\N{U+20A4}",
"\N{U+20A5}",
"\N{U+20A6}",
"\N{U+20A7}",
"\N{U+20A8}",
"\N{U+20A9}",
"\N{U+20AA}",
"\N{U+20AB}",
"\N{U+20AC}",
"\N{U+20AD}",
"\N{U+20AE}",
"\N{U+20AF}",
"\N{U+20B0}",
"\N{U+20B1}",
"\N{U+20B2}",
"\N{U+20B3}",
"\N{U+20B4}",
"\N{U+20B5}",
"\N{U+20B6}",
"\N{U+20B7}",
"\N{U+20B8}",
"\N{U+20B9}",
"\N{U+20BA}",
"\N{U+20BB}",
"\N{U+20BC}",
"\N{U+20BD}",
"\N{U+20BE}",
"\N{U+20BF}",
);

    chdir $tmpdir;
    for my $d (@dirs ) {
        mkdir $d;
        chdir $d;
    }

    my $x = cwd();
    utf8::decode($x) or die "$!";
    my $y = join('/', $tmpdir, @dirs);
    my $z = File::Spec->catdir($tmpdir, @dirs);
    print STDERR  "-->$x<--\n";
    if ( utf8::is_utf8($x) ) { print STDERR "utf8" } else { print "not utf8\n"; }
    print STDERR  "-->$y<--\n";
    if ( utf8::is_utf8($y) ) { print STDERR "utf8" } else { print "not utf8\n"; }
    print STDERR  "-->$z<--\n";
    if ( utf8::is_utf8($z) ) { print STDERR "utf8" } else { print "not utf8\n"; }
    is($x, join('/', $tmpdir, @dirs), 'yes!');
    is($x, $z, 'yes2!');
#
#    my $tmpdir = "$tmpdir";
#    for my $i ( $tmpdir, @dirs ) {
#        print "$i: ";
#        if ( utf8::is_utf8($i) ) { print "UTF8" } else { print "no";}
#        print "\n";
#    }
#    utf8::decode($tmpdir) or die "fuck!";
#    print "$tmpdir: ";
#    if ( utf8::is_utf8($tmpdir) ) { print "UTF8" } else { print "no";}
#    print "\n";
#
#    my $x = _cwd();
#    my $t = "$tmpdir";
#    my $y = File::Spec->catdir( $tmpdir, @dirs );
#    #my $y = File::Spec->catdir( $tmpdir, @dirs );
#    print STDERR "x>$x<\n";
#    print STDERR "y>$y<\n";
#
#    use Unicode::Normalize qw( NFC );
#
#    if ( NFC($x) eq NFC($y) ) {print STDERR "OK\n"; } else { print STDERR "NOK\n"; }
#    die;
#
#    print STDERR __LINE__, ': ', `pwd`;
#    print STDERR __LINE__, ': ', cwd(), "\n";
#    print STDERR __LINE__, ': ', File::Spec->canonpath( cwd() ), "\n";
#    print STDERR __LINE__, ': ', _cwd(), "\n";
#    print STDERR __LINE__, ': ', File::Spec->catdir( $tmpdir, @dirs ), "\n";
#    print STDERR __LINE__, ': ', File::Spec->catdir( @dirs ), "\n";
#    use Path::Tiny;
#    print STDERR __LINE__, ': ', path($tmpdir)->child(@dirs)->stringify(), "\n";
#


    chdir $basedir;

    is( App::DCMP::_chdir( $tmpdir, \@dirs ), undef, '_chdir($tmpdir, \@dirs) returns undef' );
    is( _cwd(), File::Spec->catdir( $tmpdir, @dirs ), '... and the cwd is correct' );
    #
    done_testing();

    exit 0;
}

# vim: ts=4 sts=4 sw=4 et: syntax=perl
